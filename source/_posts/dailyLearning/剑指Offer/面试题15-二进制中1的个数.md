---
title: 面试题15.二进制中1的个数
date: 2020-06-04 18:15:20
categories:
- Leetcode
tags:
- Algorithm
- 位运算
---

# 题目

> 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
>
> 示例 1：
>
> ```
> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
> ```
>
>
> 示例 2：
>
> ```
> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
> ```
>
>
> 示例 3：
>
> ```
> 输入：11111111111111111111111111111101
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
> ```
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 思路

最简单的方法是用一个 mask 逐位进行判断并计数。

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        if(n < 2) return n;
        int cnt = 0;
        for(uint32_t mask=1, time=0; time<32; mask<<=1, ++time) {
            if(n & mask) ++cnt;
        }
        return cnt;
    }
};
```

## 巧用 $n\&(n-1)$

简单来说，通过归纳可以得出：对一个二进制数$n$，$n-1$相当于把$n$最低位的1及其更低位取反，高位不变，此时如果对 $n$ 和 $n-1$ 做与操作，效果是抹去了最低位1。

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        if(n < 2) return n;
        int cnt = 0;
        while(n) {
            ++cnt;
            n &= n-1;
        }
        return cnt;
    }
};
```

