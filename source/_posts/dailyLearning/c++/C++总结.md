---
title: c++总结
toc: true
categories: 
- Cpp
- summary
tag: 
- Cpp
---
本篇博客用来总结自己在学习/复习C++的过程中遇到的新的/没掌握的细节。章节划分就参照《c++ Primer》一书的章节。

<!--more-->

# 第七章、类

## 7.5.3 默认构造函数的作用

一个类对象被在被**默认初始化或值初始化**时执行**默认构造函数**。

默认初始化发生在：

- 在**块作用域内**不使用任何初始值定义一个**非静态变量**或者**数组**时；

  ```c++
  class Foo{
      int i; // 执行默认初始化，调用合成的默认构造函数
      int arr[20]; // 执行默认初始化，调用合成的默认构造函数
  }
  ```

- 当一个类的本身含有**类类型的成员**且使用**合成的默认构造函数时**；也意味着类类型的成员没有显式地定义构造函数：

  ```c++
   // 由于该类的类成员Foo1使用合成的默认构造函数，因此Foo使用默认初始化
  class Foo{
      int i = 0;
      struct Foo1{
          double d;
      }
  }
  ```

- 当类类型的成员没有在**构造函数初始化列表**中显式初始化时：

  ```c++
  class Foo{
  public:    
      Foo() = default;
      Foo(int ii): i(ii) {} // 未在初始化列表中显式初始化Foo1
  private:
      int i;
      struct Foo1{
          Foo1(): d(0) {}
          double d;
      }
  }
  ```

值初始化发生在：

- 数组初始化过程中，提供的初始值数量小于数字大小时（默认填0）；

- 不使用初始值定义一个局部静态变量时；

- 使用形如`T()`的表达式显式的请求值初始化时，其中T为类型名。比如`vector`接受单参数的构造函数就是就用这个参数对他的元素初始化器进行值初始化。

  ```c++
  class Foo{
      int arr[100] = {0, 0}; // 类初始化时执行值初始化
      int arr[10][10] = {{0, 0}, {0}}; // 类初始化时执行值初始化
      int getcount(){
          static int cnt; // 值初始化为0
          vector<int> v(10); // vector被值初始化
          return cnt;
      }
  }
  ```

特别地，当一个类含有类类型成员，但是该类成员的类类型没有默认构造函数，并且包含这个类的类也没有在构造函数中显式初始化这个成员，那么出现错误：这个类类型成员没有初始值。

```c++
class NoDefault{
public:
    NoDefault(const std::string&);
};
struct A{
    NoDefault my_mem;
};
A a; // 错误，无法为A合成构造函数
struct B{
    B(){}; // 错误，b_member没有初始值
    NoDefault b_mem;
}
```

### 使用默认构造函数

如果想要使用类的默认构造函数实例化一个类：

```c++
class Foo;
void main(){
    Foo F(); // 错误，该声明语句实际上定义了一个返回类型为Foo的函数F，不接受任何参数
    Foo F2; // 正确，F2是个默认初始化的Foo对象
}
```

## 7.5.4 隐式的类类型转换

如果构造函数只接受一个实参，那么它实际上定义了一个将该实参隐式转换为类类型的隐式转换机制，这种构造函数有时被称为转换构造函数。

```c++
class Foo{
private:
	int i;
public:
    Foo() = default;
    Foo(const string& s); // 定义了隐式转换：string->Foo
    void get(Foo foo);
};

Foo foo;
string s{"11111"};
foo.get(s); // 实际上是先调用转化构造函数构造了一个临时对象，再将该临时对象的，由于get的参数为常量引用，所以我们可以给该参数传递一个临时量。
foo.get("11111"); // 错误，字面值常量->string->Foo经历了两次隐式转换
foo.get(string("11111")); //正确，通过string的构造函数构造一个临时string变量,显式转string，隐式转Foo
foo.get(Foo("11111")); // 正确，隐式转string，显式转Foo
```

### 抑制构造函数定义的隐式转换

再要求隐式转换的程序上下文中，将构造函数声明为`explicit`来阻止隐式转换

```c++
class Foo{
private:
	int i;
public:
    Foo() = default;
    explicit Foo(const string& s); // 定义了隐式转换：string->Foo
    void get(Foo foo);
};
Foo foo;
foo.get(string("11111")); // 错误
```

`explicit`关键字只对单参数构造函数有效，因为多实参构造函数不能进行隐式转换，也就无需使用。

**只能在类内声明构造函数时使用explicit关键字**，类外定义时不应重复。

### explicit构造函数只能用于直接初始化

由于在**拷贝初始化的过程中发生了隐式转换**，因此explicit的构造函数只能用于直接初始化。

### 为转换显式地使用构造函数

我们可以使用explicit构造函数进行显式的强制转换

```c++
foo.get(Foo("11111")); // 正确，隐式转string，显式转Foo
```

### 标准库中含有显式构造函数的类

- 接受`const char*`的`string`构造函数，**不是**`explicit`的；
- 接受一个容量参数的`vector`构造函数，**是**`explicit`的。

# 第十三章

## 13.6.1 右值引用

右值引用的引入是为了支持移动操作，所谓右值引用是指**必须绑定到右值的引用**，即：能且只能绑定到一个即将要销毁的对象上，可以实现自由地将一个右值引用的资源“移动”到另一个对象中。

右值引用的特性与常规引用的特性完全相反：可以将一个右值引用绑定到

1. 要求转换的表达式
2. 字面常量
3. 返回右值的表达式

上，但是不能把一个右值引用绑定到左值上：

```c++
int i = 42;
int &r = i; // 正确
int &&rr = i; // 错误，i是左值
int &r2 = i * 42; // 错误，i*42返回右值
int &&rr2 = i * 42; // 正确
const int &r3 = i * 42; // 正确，可以将const引用绑定到右值，这样可以保证右值不被修改 
```

返回左值引用的函数：赋值、下标、解引用、前置递增/递减 运算符

返回非引用类型的函数：算数、关系、位、后置递增/递减 运算符

**Note：**由于变量是一个只有运算对象而没有运算符的表达式，而变量表达式都是左值，因此我们**不能将一个右值引用绑定到一个右值引用类型的表达式上**。