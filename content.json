{"meta":{"title":"Frank's cabin","subtitle":"","description":"","author":"Frank Young","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"dailyLearning/Leetcode/如何建立二叉树？","slug":"dailyLearning/Leetcode/如何建立二叉树？","date":"2020-05-05T07:52:23.481Z","updated":"2020-05-03T15:19:40.656Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/如何建立二叉树？/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F/","excerpt":"","text":"如何建立二叉树？为了在本地IDE上编写和测试有关二叉树的算法，首先要会构建二叉树。","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/Recursive 递归的思路","slug":"dailyLearning/Leetcode/Recursive 递归的思路","date":"2020-05-05T07:52:23.480Z","updated":"2020-05-02T15:04:54.756Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/Recursive 递归的思路/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/Recursive%20%E9%80%92%E5%BD%92%E7%9A%84%E6%80%9D%E8%B7%AF/","excerpt":"","text":"如何理解和解决递归问题 关于如何判断一个问题是否可以用递归解决 写递归的思路是什么？ 想清楚我们的函数要解决的问题是什么 找到递归结束的条件，常用的方法是考虑参数很小的情况，小到可以直接得出想要的结论，这时可以把这个作为结束条件，但是需要注意条件泄漏 找到等价关系式，迭代表达式（核心） 写完等价关系式后，要返回去检查会不会出现无限递归的情况，递归条件是否严谨，同时也需要考虑特殊测试用例 例子： 求阶乘 我们要求阶乘 n=1时ans=1，n=2时ans=2 等价关系式f(n) = n*f(n-1) 每次递归使n-1，因此递归结束条件可以从1或2开始向下兼容 求斐波那契数列第n项 小青蛙跳台阶 我们要求总的跳法数目 n=1时ans=1，n=2时ans=2，n=3时ans=3 直接找出等价关系式有点困难，需要把问题拆解到每一个选择：每一次决定都有两个选项：跳一级或跳两级。跳一级使得剩余台阶n-1，这种选择使得我们后续共有f(n-1)种跳法；跳两级使得剩余台阶数n-2，这种选择使得我们后续共有f(n-2)种跳法，那么我本次做选择之前就共有f(n-2)+f(n-1)种跳法，即f(n)=f(n-1)+f(n-2)种跳法，这也就是递归表达式 由于n每次递减1和2，因此我们得结束条件需要从n=2开始向下兼容，如果输入允许为0，那么还要一并考虑n=0的情况 反转单链表 假设函数reverseList(head)的功能时反转单链表，其中head表示链表头节点。 结束条件：链表为空，或者只有一个节点 等价关系：把链表头单独拆下来，将整个链表看成一个节点（链表头）和剩余链表，那么反转整个链表就是把剩余链表反转，并且把表头插到尾部，自身指向null。而反转的剩余链表，尾部为反转前的头部，因此只要再反转前保存tmp = head-&gt;next，反转后tmp-&gt;next = head，再 head-&gt;next = null，反转就完成了。 递归的优化 考虑是否重复计算","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/617.合并二叉树","slug":"dailyLearning/Leetcode/617.合并二叉树","date":"2020-05-05T07:52:23.479Z","updated":"2020-05-04T03:16:00.504Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/617.合并二叉树/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"617.合并二叉树 题目： 123456789101112131415161718192021给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。示例 1:输入: Tree 1 Tree 2 1 2 &#x2F; \\ &#x2F; \\ 3 2 1 3 &#x2F; \\ \\ 5 4 7 输出: 合并后的树: 3 &#x2F; \\ 4 5 &#x2F; \\ \\ 5 4 7注意: 合并必须从两个树的根节点开始。 思路： 两棵二叉树合并，最简单的思路就是两棵树同时做相同的遍历，就像遍历单棵树一样，不过判断条件是两棵树相同位置的节点。 递归代码如下： 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if(!t1 &amp;&amp; !t2) return nullptr; else if(!t1) return t2; else if(!t2) return t1; else&#123; t1-&gt;val += t2-&gt;val; t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); &#125; return t1; &#125;&#125;; 但是执行用时和内存消耗都很严重。分析： 由于两棵树需要都遍历一遍（除去不是两侧节点都不为空的情况），因此时间复杂度O(M+N)（空指针的情况不访问节点，只修改指针）；空间复杂度由于是直接修改t1，因此也是O(N)。 递归： 由于需要比较每两个对应的节点，那么参考对称二叉树的思路，将每个节点的指针保存起来，两棵树对应的节点相邻放置，每次判断两个节点。需要注意的树如果节点为空，要保存空节点，必须要占位；其次，为了改变t1所在的树，需要在必要时新建节点。在迭代开始时首先处理根节点，其次对左树和右树的左右节点进行判断，进行相应新建。 这样的思路，空间复杂度首先为O(M+N),时间复杂度一样为O(M+N)。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if(!t1) return t2; else if(!t2) return t1; queue&lt;TreeNode*&gt; q; q.push(t1); q.push(t2); while(!q.empty())&#123; auto l = q.front(); q.pop(); auto r = q.front(); q.pop(); l-&gt;val += r-&gt;val; if(!(!l-&gt;left &amp;&amp; !r-&gt;left))&#123; if(!l-&gt;left) l-&gt;left = new TreeNode(0); else if(!r-&gt;left) r-&gt;left = new TreeNode(0); q.push(l-&gt;left); q.push(r-&gt;left); &#125; if(!(!l-&gt;right &amp;&amp; !r-&gt;right))&#123; if(!l-&gt;right) l-&gt;right = new TreeNode(0); else if(!r-&gt;right) r-&gt;right = new TreeNode(0); q.push(l-&gt;right); q.push(r-&gt;right); &#125; &#125; return t1; &#125;&#125;; Note：这中间出错的点：需要在当前步骤新建左右节点，指针才有效，否则空节点入队已经是一个空节点的拷贝，对其进行赋值是无效的。","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/226.翻转二叉树","slug":"dailyLearning/Leetcode/226.翻转二叉树","date":"2020-05-05T07:52:23.478Z","updated":"2020-05-05T02:58:08.232Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/226.翻转二叉树/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"226.翻转二叉树 题目： 123456789101112131415161718翻转一棵二叉树。示例：输入： 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\1 3 6 9输出： 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\9 6 3 1 思路：翻转二叉树即为镜像左子树和右子树，逐节点交换左右两节点的指针即可。 迭代： 使用前序遍历，交换所有左右子节点。 代码如下： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; auto rt = root; stack&lt;TreeNode*&gt; st; while(!st.empty() || root)&#123; if(root)&#123; swap(root-&gt;left, root-&gt;right); st.push(root-&gt;right); root = root-&gt;left; &#125; else&#123; root = st.top(); st.pop(); &#125; &#125; return rt; &#125;&#125;; 时间复杂度：O(N)，空间复杂度O(N) 递归： 如上所述，翻转二叉树需要对每个节点交换其左右节点，需要遍历二叉树，并交换左右节点； 终止条件：节点为空； 递推公式：DFS或BFS NOTE：不能使用中序遍历，如果在先遍历左侧节点，中间交换了左右节点位置，访问右侧节点时会发生错误。 前序遍历代码如下： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; preorderTrversal(root); return root; &#125;private: void preorderTrversal(TreeNode* root)&#123; if(!root) return; swap(root-&gt;left, root-&gt;right); preorderTrversal(root-&gt;left); preorderTrversal(root-&gt;right); &#125;&#125;; 后序遍历也是一样。时间复杂度O(N)，空间复杂度O(N)。","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/144.二叉树的前序遍历","slug":"dailyLearning/Leetcode/144.二叉树的前序遍历","date":"2020-05-05T07:52:23.477Z","updated":"2020-05-02T03:48:08.281Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/144.二叉树的前序遍历/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"144. 二叉树的前序遍历早些的学习笔记在这里：[二叉树中序遍历](./94. 二叉树的中序遍历/)。 本文件只记录该题的解题思路和代码： 先上代码： 迭代代码 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; stk;//栈中存放右子节点未处理的根节点 auto cur = root; while(!(stk.empty() &amp;&amp; cur==nullptr))&#123; while(cur)&#123; ans.emplace_back(cur-&gt;val); stk.push(cur); cur = cur-&gt;left; &#125; cur = stk.top()-&gt;right; stk.pop(); &#125; return ans; &#125;&#125;; 思路： 前序遍历的方法，对于每个节点来说都是如下： 到达当前节点，输出当前节点值，记录当前节点（后续还要搜索右子节点） 向左寻找左子节点，存在则将当前节点更新为左子节点；不存在则更新为右子节点 由于右子节点也可能不存在，此时针对到达新的节点时，此节点为空的情况，需要出栈前驱节点，并将当前节点更新为前驱节点的右子节点 相应代码如下： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; stk;//栈中存放右子节点未处理的根节点 auto cur = root; while(!(stk.empty() &amp;&amp; cur==nullptr))&#123; if(!cur)&#123; cur = stk.top()-&gt;right; stk.pop(); continue; &#125; ans.emplace_back(cur-&gt;val); if(cur-&gt;left)&#123; stk.push(cur); cur = cur-&gt;left; &#125; else cur = cur-&gt;right; &#125; return ans; &#125;&#125;;","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/102.二叉树的层序遍历","slug":"dailyLearning/Leetcode/102.二叉树的层序遍历","date":"2020-05-05T07:52:23.476Z","updated":"2020-05-04T08:34:01.098Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/102.二叉树的层序遍历/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"102.二叉树的层序遍历 题目： 1234567891011121314151617给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。示例：二叉树：[3,9,20,null,null,15,7], 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7返回其层次遍历结果：[ [3], [9,20], [15,7]] 思路： 迭代：由于层序遍历需要从左向右遍历每一层，比较容易想到的是把每个结点的左右子节点按顺序插入队列，再按照队列顺序遍历。问题是怎么换行，可以用两个队列交替使用，每次遍历一个，向另外一个插入，这样遍历结束一个队列意味着本层结束。结束条件为两个队列都为空。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if(!root) return &#123;&#125;; queue&lt;TreeNode*&gt; q1, q2; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; q1.push(root); while(!(q1.empty() &amp;&amp; q2.empty()))&#123; while(!q1.empty())&#123; if(q1.front())&#123; tmp.emplace_back(q1.front()-&gt;val); q2.push(q1.front()-&gt;left); q2.push(q1.front()-&gt;right); &#125; q1.pop(); &#125; if(!tmp.empty()) ans.emplace_back(tmp); tmp.clear(); while(!q2.empty())&#123; if(q2.front())&#123; tmp.emplace_back(q2.front()-&gt;val); q1.push(q2.front()-&gt;left); q1.push(q2.front()-&gt;right); &#125; q2.pop(); &#125; if(!tmp.empty()) ans.emplace_back(tmp); tmp.clear(); &#125; return ans; &#125;&#125;; 调试中没考虑到的问题：空的层不插入结果容器。 时间复杂度：每个节点访问一次，O(N)；空间复杂度：两个队列加答案容器：O(N)。 递归：我认为这道题不适合递归，因为输入为一个节点指针，无法知道本层的其他节点。 我错了，可以用递归，不过递归不是调用自身，是另外写一个递归函数。 思路： 递归函数实现的功能：层序遍历二叉树（的一部分）；需要的参数：本层所有节点 终止条件：根节点为空 递推关系：遍历一层，输出，层序遍历树的剩余部分。 代码： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; lvlOdr(&#123;root&#125;); return ans; &#125;private: void lvlOdr(vector&lt;TreeNode*&gt; curLevel)&#123; if(curLevel.empty()) return; vector&lt;TreeNode*&gt; nextLevel; vector&lt;int&gt; tmp; for(const auto&amp; ptr:curLevel)&#123; if(ptr)&#123; tmp.emplace_back(ptr-&gt;val); nextLevel.emplace_back(ptr-&gt;left); nextLevel.emplace_back(ptr-&gt;right); &#125; &#125; if(!tmp.empty()) ans.emplace_back(tmp); lvlOdr(nextLevel); &#125; vector&lt;vector&lt;int&gt;&gt; ans;&#125;; 时间复杂度：O(N)，空间复杂度：O(N)","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/101.对称二叉树","slug":"dailyLearning/Leetcode/101.对称二叉树","date":"2020-05-05T07:52:23.474Z","updated":"2020-05-02T14:30:39.461Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/101.对称二叉树/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"101.对称二叉树题目： 12345678910111213141516171819给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 &#x2F; \\ 2 2 &#x2F; \\ &#x2F; \\3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 &#x2F; \\ 2 2 \\ \\ 3 3 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ 我的思路： 递归： 函数实现的功能是判断二叉树是否对称 一棵二叉树镜像对称的条件是左子树和右子树镜像对称，那么这棵二叉树镜像对称。那么两棵树满足怎样的条件为镜像对称？ 根节点相同 对于每个节点，都与另一棵树对称 两边不对称时结束（仅一侧为空或两侧不为空但不相等），两边均为空时结束 到达一个节点，首先判断根节点是否对称，再判断左右子树是否对称 代码： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; auto l = root-&gt;left; auto r = root-&gt;right; return isSym(l, r); &#125;private: bool isSym(TreeNode* lc, TreeNode* rc)&#123; if(lc == nullptr &amp;&amp; rc == nullptr) return true; else if(!lc || !rc) return false; else if(lc-&gt;val != rc-&gt;val) return false; else&#123; if(isSym(lc-&gt;left, rc-&gt;right)) return isSym(lc-&gt;right, rc-&gt;left); else return false; &#125; &#125;&#125;; Note: 出错原因是忘记考虑空输入的特殊测试用例，以及少考虑两侧不为空但不相等的情况 迭代： 先贴代码： 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; auto l = root-&gt;left; auto r = root-&gt;right; queue&lt;TreeNode*&gt; q; q.push(l); q.push(r); while(!q.empty())&#123; l = q.front(); q.pop(); r = q.front(); q.pop(); if(!l ^ !r) return false; else if(l!=nullptr &amp;&amp; r!=nullptr &amp;&amp; (l-&gt;val != r-&gt;val)) return false; else if(l == nullptr &amp;&amp; r == nullptr) continue; else&#123; q.push(l-&gt;left); q.push(r-&gt;right); q.push(l-&gt;right); q.push(r-&gt;left); &#125; &#125; return true; &#125;&#125;; 思路比较常规，类似BFS，按层序将两棵树的镜像位置节点取出放入队列，排队比较，每次比较一对。 复习：队列适配器queue，其push操作插入队尾，pop弹出队首。","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/96.不同的二叉搜索树","slug":"dailyLearning/Leetcode/96.不同的二叉搜索树","date":"2020-05-05T07:52:23.473Z","updated":"2020-05-05T05:38:35.917Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/96.不同的二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"96.不同的二叉搜索树 题目： 123456789101112131415161718给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？示例:输入: 3输出: 5解释:给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;unique-binary-search-trees著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：首先明确二叉搜索树BST的规则：左子节点的key小于root的key小于右子节点的key。那么当我们有1~nn个元素的时候，任意一个元素作为根节点，左子节点（树）只能选择比它小的，e.g.有m种，右子节点（树）只能选择比它大的，e.g.有n种，那么这个node有mn种选择。 想到这里很容易想到用递归解决：然而这中间需要求值，我们可以保存已经求解过的值避免重复计算，动态规划； 函数的功能是求二叉搜索树的组合方式有多少种 结束条件是元素序列中元素个数为1（输入不为0），只有1种组合方式 （动态规划的）递推公式：一棵树的组合方式个数为对每种root的值对应的左右子树组合方式个数之积求和。 递归代码： 1234567891011121314class Solution &#123;public: int numTrees(int n) &#123; if(n&lt;2) return 1; int sum = 0;//局部变量不初始化会出错 for(int i=1; i&lt;=n; ++i)&#123; int numL = i-1; int numR = n-i; sum += numTrees(numL)*numTrees(numR); &#125; return sum; &#125;&#125;; 可以通过单个n比较小的测试用例，但是大的n会超时，分析递归的时间复杂度： O(?)，很大。 题目答案为动态规划：与其自上而下去递归计算，不如自下而上先求解n比较小的时候的情况，保存在容器中，求解更大n的时候直接利用计算结果，小的空间换很多时间。代码如下： 1234567891011121314151617class Solution &#123;public: int numTrees(int n) &#123; if(n&lt;2) return 1; vector&lt;int&gt; num(n+1); num[0] = num[1] = 1; for(int i=2; i&lt;=n; ++i)&#123; int sum = 0; for(int j=1; j&lt;=i; ++j)&#123; sum += num[j-1]*num[i-j]; &#125; num[i] = sum; &#125; return num[n]; &#125;&#125;; 总结：此动态规划区别于递归写法之处：不调用自身。递归是从任意输入，通过调用自己，每一次收敛输入值，最终求得输入很小时的解，然后层层返回。而动态规划为了规避重复运算，从较小的解开始求解，由于求任意输入的解时都需要用到更小输入的解，每次运算保存小输入解的值，直至对输入进行求解。动态规划保证了没有重复计算的解。时间复杂度：$$O(N(N+1)/2)=O(N^2)$$空间复杂度：O(N)。 数学演绎法（套公式）：卡塔兰数：只记结论： 卡塔兰数C_n,$$C_0=c_1=1,C_{n+1}=\\frac{2(2n+1)} {n+2}C_n$$这个公式即为动态规划种内循环的解。","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/94. 二叉树的中序遍历","slug":"dailyLearning/Leetcode/94. 二叉树的中序遍历","date":"2020-05-05T07:52:23.472Z","updated":"2020-05-05T08:24:08.925Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/94. 二叉树的中序遍历/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"title: 94. 二叉树的中序遍历 toc: true 题目：给定一个二叉树，返回它的中序遍历。 示例 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 考点： 二叉树的中序遍历。二叉树的遍历方式分为四种： 中序遍历：若数为空，空操作返回，否则从根节点开始（不访问根节点），一路向下访问左子节点（一路向下的过程中也不访问节点），直到左子节点为null。 前序遍历 后序遍历 层序遍历 Note：中序、前序、后序均属于深度优先遍历（DFS），而层序遍历属于广度优先遍历（BFS）； 代码 我们先从简单的递归实现开始 /** Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; /class Solution {public: vector inorderTraversal(TreeNode* root) {if(!root) return {}; else { inorderTraversal(root-&gt;left); ans.push_back(root-&gt;val); inorderTraversal(root-&gt;right); } return ans; }private: vector ans;}; 递归实现的时间复杂度为O(N)，因为很明显要遍历所有的元素； 空间复杂度O(N)，平均情况为BST深度T(N)=logN； 官方给出的解题思路除了迭代法，还有利用辅助栈、莫里斯遍历 辅助栈：在递归实现中，我们相当于在函数调用自身的时候利用了系统虚拟内存的栈空间；而迭代实现我们要复现这一过程。每到达一个新的节点，我们首先检查左子节点是否为null，若不为null则将当前节点入栈，指向左子节点；若为null则读取自身节点值，并检查右子节点，如果右子节点为null则出栈，读取自身节点 代码如下： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { if(!root) return {}; stack&lt;TreeNode*&gt; stk; vector&lt;int&gt; ans; auto cur = root; //结束条件为，栈空（BST根节点出栈或最后一个未访问节点出栈）且无右子节点（保证是最后一个节点出栈） while(!(stk.empty() &amp;&amp; cur==nullptr)){ while(cur != nullptr){ stk.push(cur); cur = cur-&gt;left;//一路向下至最左 } cur = stk.top();//触底则出栈，保存值 stk.pop(); ans.push_back(cur-&gt;val); cur = cur-&gt;right;//接着检查右侧subtree } return ans; } }; 迭代实现与递归实现时间与空间复杂度相同，均为O(N)； 莫里斯遍历： 特点在于O(1)的空间复杂度，缺点是会破坏二叉树结构，变成一个链表； idea: 利用线索二叉树的概念。对于一个二叉树，中序遍历最后输出的都是树的最右节点（包括根节点），极端情况是一棵二叉树只有一个节点（根节点）时，这个节点也是最后输出的节点。 从一颗二叉树的整体来看，中序遍历即为：遍历左侧树，输出根节点，遍历右侧树。 那么结合上一点，对于一个根节点，如果它左子节点不为空，那么其左子树的最右节点的后继节点为根节点，而一个最右节点必然是没有右子节点的，因此将最右节点的right指针指向其后继节点：根节点。如此，对于根节点，其左子树的一个节点指向了自己时，意味着该根节点的左子树已经遍历完了，此时可以输出根节点本身了，然后再遍历右子树。 实现： 对于每个节点：先假设该节点存在，那么用一个辅助指针记录以该节点的位置，用于判断该节点左子树是否遍历完成； 如果该节点不存在左子节点，那么输出当前节点，将当前节点更新为右子节点；如果该节点存在左子节点，找到左子树的最右节点；","categories":[],"tags":[]},{"title":"dailyLearning/Leetcode/题型归纳","slug":"dailyLearning/Leetcode/题型归纳","date":"2020-05-05T07:52:23.470Z","updated":"2020-05-02T04:22:38.029Z","comments":true,"path":"2020/05/05/dailyLearning/Leetcode/题型归纳/","link":"","permalink":"http://yoursite.com/2020/05/05/dailyLearning/Leetcode/%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3/","excerpt":"","text":"数据结构和算法类型的归纳（参考别人）","categories":[],"tags":[]},{"title":"My first blog!!!","slug":"My-first-blog","date":"2020-05-05T06:04:27.000Z","updated":"2020-05-05T06:09:38.049Z","comments":true,"path":"2020/05/05/My-first-blog/","link":"","permalink":"http://yoursite.com/2020/05/05/My-first-blog/","excerpt":"","text":"This blog means that I’m going to build my own blog with Hexo!","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-05-05T05:58:50.891Z","updated":"2020-05-05T05:58:50.891Z","comments":true,"path":"2020/05/05/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}